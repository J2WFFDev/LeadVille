    async def calibration_notification_handler(self, characteristic, data):
        """Collect calibration samples during startup - per sensor approach"""
        if not self.collecting_calibration:
            return

        # Identify which sensor sent this data
        sensor_mac = None
        device = characteristic.service.client
        
        # Find sensor MAC from device address
        for bt50_sensor in BT50_SENSORS:
            if device.address.upper() == bt50_sensor.upper():
                sensor_mac = bt50_sensor
                break
        
        if not sensor_mac:
            # Could not identify sensor, skip this sample
            return
            
        # Initialize sensor calibration if not exists
        if sensor_mac not in self.per_sensor_calibration:
            self.per_sensor_calibration[sensor_mac] = {
                "samples": [],
                "baseline": {},
                "complete": False,
                "target_samples": CALIBRATION_SAMPLES
            }

        # For calibration, parse data even if shot_detector import failed
        try:
            if PARSER_AVAILABLE:
                # Use the imported parser
                result = parse_5561(data)
                if result and result['samples']:
                    # Collect raw values from all samples in this notification
                    for sample in result['samples']:
                        vx_raw, vy_raw, vz_raw = sample['raw']
                        
                        # Add to per-sensor calibration data
                        self.per_sensor_calibration[sensor_mac]["samples"].append({
                            'vx_raw': vx_raw,
                            'vy_raw': vy_raw,
                            'vz_raw': vz_raw,
                            'timestamp': time.time()
                        })
                        
                        # Also add to legacy samples for compatibility
                        self.calibration_samples.append({
                            'vx_raw': vx_raw,
                            'vy_raw': vy_raw,
                            'vz_raw': vz_raw,
                            'timestamp': time.time()
                        })

                        # Check if this sensor has enough samples
                        sensor_sample_count = len(self.per_sensor_calibration[sensor_mac]["samples"])
                        if sensor_sample_count >= CALIBRATION_SAMPLES:
                            self.per_sensor_calibration[sensor_mac]["complete"] = True
                            
                        # Check if ALL sensors have enough samples
                        all_complete = True
                        total_samples = 0
                        sensor_progress = []
                        
                        for s_mac, s_data in self.per_sensor_calibration.items():
                            sample_count = len(s_data["samples"])
                            total_samples += sample_count
                            is_complete = sample_count >= CALIBRATION_SAMPLES
                            sensor_progress.append(f"{s_mac[-5:]}:{sample_count}/{CALIBRATION_SAMPLES}")
                            if not is_complete:
                                all_complete = False
                        
                        # Update progress display
                        if total_samples % 10 == 0:  # Every 10 samples
                            progress_str = ", ".join(sensor_progress)
                            print(f"\rðŸ“Š Calibration Progress: {progress_str}", end='', flush=True)
                        
                        if all_complete:
                            self.collecting_calibration = False
                            break
                            
            else:
                # Fallback: manually parse WitMotion 5561 frames for calibration
                if len(data) >= 44 and data[0] == 0x55 and data[1] == 0x61:
                    # Extract first sample from 5561 frame
                    vx_raw = struct.unpack('<h', data[14:16])[0]
                    vy_raw = struct.unpack('<h', data[16:18])[0]
                    vz_raw = struct.unpack('<h', data[18:20])[0]

                    # Add to per-sensor calibration data
                    self.per_sensor_calibration[sensor_mac]["samples"].append({
                        'vx_raw': vx_raw,
                        'vy_raw': vy_raw,
                        'vz_raw': vz_raw,
                        'timestamp': time.time()
                    })
                    
                    # Also add to legacy samples for compatibility
                    self.calibration_samples.append({
                        'vx_raw': vx_raw,
                        'vy_raw': vy_raw,
                        'vz_raw': vz_raw,
                        'timestamp': time.time()
                    })

                    # Check completion as above
                    sensor_sample_count = len(self.per_sensor_calibration[sensor_mac]["samples"])
                    if sensor_sample_count >= CALIBRATION_SAMPLES:
                        self.per_sensor_calibration[sensor_mac]["complete"] = True
                        
                    # Check if ALL sensors complete
                    all_complete = all(len(s_data["samples"]) >= CALIBRATION_SAMPLES 
                                     for s_data in self.per_sensor_calibration.values())
                    
                    if all_complete:
                        self.collecting_calibration = False

        except Exception as e:
            self.logger.error(f"Calibration data collection failed for {sensor_mac}: {e}")